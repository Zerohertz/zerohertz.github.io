---
title: Introduction of C++
date: 2020-07-01 13:32:51
categories:
- Etc.
tags:
- C, C++
---
# C++?

+ C언어에 객체 지향 프로그래밍 기능을 추가하여 만든 언어
+ C언어만큼 효율적이고 속도가 빠르며 이식성이 좋은 절차적 프로그래밍(Procedural programming) 가능
+ 복잡한 프로그램을 작성하는데 매우 효과적인 방법으로 알려진 객체 지향 프로그래밍(Object-oriented programming) 가능
+ 템플릿을 이용하는 일반화 프로그래밍(Generic programming) 가능

<!-- More -->

***

# 프로그래밍 기법의 발전

## 절차적 프로그래밍

+ 프로그램은 흔히 데이터와 알고리즘으로 이루어져 있다고 말함
  + 데이터 : 프로그램에서 사용하는 정보
  + 알고리즘(Algorithm) : 컴퓨터로 문제를 해결하는 절차
+ 초기의 프로그래밍은 데이터보다 알고리즘(절차)의 작성에 치중
+ 절차를 중시하는 프로그래밍 기법 - 절차적 프로그래밍(Procedural programming)
+ GOTO문과 같이 무조건 특정한 위치로 점프하는 문장 난해
+ 이것을 해결하기 위해 1970년대 구조화 프로그래밍(Structural programming) 개발
  + 순차, 반복, 선택만을 이용하여 순차적으로 프로그램하는 방식
  + 명확하고 검사와 오류 수정이 쉬운 프로그램 작성 가능
  + 독립적인 모듈(Module)이라는 단위로 나누어 작성하는 기법으로 발전
  + 하향식(Top-down) 설계 : 큰 문제를 작은 문제들로 계속 나누어가는 것
  + 데이터보다는 주로 문제를 해결하는 알고리즘(절차)에 집중 - 프로그램 규모가 커지면 역부족

## 객체 지향 프로그래밍

+ 절차적 프로그래밍의 문제점을 해결하기 위해 객체 지향 프로그래밍 등장
+ 절차적 프로그래밍에서 알고리즘을 중요시했던 것과는 반대로 객체 지향에서는 데이터를 중요시함
  + 문제에서 필요한 데이터를 먼저 설계
+ 클래스 : 데이터를 나타낼 때 사용하는 도구
  + 클래스에는 데이터 외에 데이터를 처리하는 함수(알고리즘) 포함
+ 상향식(Bottom-up) 설계 : 낮은 수준의 클래스를 먼저 설계하고 높은 수준의 클래스 설계로 진행
+ 캡슐화 : 데이터와 알고리즘을 하나의 단위(클래스)로 묶는 것
  + 데이터에 대한 불필요한 접근 차단
  + 데이터 보호
  + 각 클래스들을 서로 독립적으로 작성 가능
+ 상속 : 비슷한 클래스가 이미 존재하고 있다면 그 클래스를 가져다가 사용하는 것
  + 그 클래스 중 바꿔야할 부분이 있다면 변경 가능
+ 다형성 : 같은 이름의 함수나 연산자를 중복 정의하여 상황에 따라 가장 적절한 함수나 연산자를 프로그램이 자동적으로 선택하도록 하는 것
+ 객체 지향의 개념에서 공통적 목표 : 코드의 재사용(Reuse)
  + 캡슐화, 상속, 다형성
  + 지금까지의 프로그램 개발이 힘들었던 이유 : 다른 사람들의 유용하고 좋은 코드 재사용 X

## 일반화 프로그래밍

+ 하나의 코드로 다양한 데이터를 처리할 수 있음
+ 데이터의 타입과 무관한 일반적인 코드를 작성하는 기법
+ 알고리즘이 타입 매개 변수(Type parameter)를 이용하여 작성
+ 1983년 에이다(Ada) 프로그래밍 언어에 의해 처음 시작
+ 동일한 작업을 여러 가지 타입에 대하여 실행하는 함수를 작성하는데 유용
+ 결과적으로 코드의 중복을 막을 수 있음
+ 특정한 데이터 타입을 지정하지 않는 일반적인 코드를 작성하고 그 코드를 여러 가지 데이터 타입에 널리 사용할 수 있도록 함

***

# 프로그램 작성 과정

1. 프로그래머
   + 에디터(Editor)
2. 소스파일 - `test.cpp`
   + 컴파일러(Compiler)
3. 오브젝트 파일 - `test.obj`
   + 링커(Linker)
4. 실행파일 - `test.exe`
   + 실행(Execution)
5. 사용자

## 편집 단계(Edit)

+ 소스 코드(Source code) : C++ 언어를 이용하여 원하는 작업의 내용을 기술하는 것 
  + 에디터를 이용하여 입력되어서 텍스트 파일로 저장되어야 함
+ 소스 파일(Source file) : 소스 코드가 들어 있는 파일
  + 확장자 : `.cpp`

## 컴파일 단계(Compile)

+ 컴파일러 : 소스 파일을 분석하여 특정한 컴퓨터에서 수행이 가능하도록 기계어로 변환
  + 소스 파일의 문장을 분석하여 문법에 맞도록 작성되었는지 체크
  + 만약 오류가 발견되면 사용자에게 오류 통보 및 컴파일 종료
    + 프로그래머는 편집 단계로 되돌아가서 소스 파일 수정
  + 만약 오류가 없다면 컴파일러는 각 문장들을 어셈블리 언어로 변환
    + 다시 어셈블리 언어는 어셈블러에 의해 기계어로 변환
    + 이 기계어로 되어 있는 파일은 오브젝트 파일(Object file)이라고 불림 - `.obj` 확장자

## 링크 단게(Link)

+ 링크(Link) : 서로 연관된 오브젝트 파일들을 라이브러리 파일들과 연결하여 하나의 실행 파일(Execute file)을 만드는 절차
+ Windows에서는 링크가 끝나면 실행가능한 파일 `.exe` 생성
+ 컴파일과 링크 두 단계로 분리시켜 실행 파일을 만드는 이유
  + 여러 개의 파일로 구성된 프로그램의 경우 각각의 파일을 따로 컴파일한 후에 링커를 통하여 결합
  + 만약 하나의 소스 파일만 변경되었다면 변경된 소스 파일만 다시 컴파일하고 나머지 파일들의 오브젝트 파일은 다시 컴파일하지 않고 사용 가능

## 실행 단게(Execute)

+ 프로그램을 실행하려면 Windows에서는 `.exe`를 클릭하거나 실행 메뉴를 사용
+ 유닉스에서는 파일명을 입력하고 엔터를 눌러 사용
+ 만약 실행 도중 오류가 발생하거나 실행 결과가 잘못되면 실행을 중단하고 다시 편집 단계로 돌아가서 소스 파일 수정

***

# Example

> test.cpp

~~~C++
#include <iostream>
using namespace std;

int main(){
    cout << "Hello, World!\n" << endl;
    cout << "end" << endl;
    return 0;
}
~~~

> Output

~~~C++
Hello, World!

end
Program ended with exit code: 0
~~~

+ 대문자와 소문자 구별
+ 주석은 `//` 혹은 `/* */`와 같이 사용
  + 주석 : 프로그램이 하는 일을 설명하는 설명 글
  + 프로그램의 실행 결과에 영향을 끼치지 않음
  + 컴퓨터를 위한 것이 아니고 프로그램을 읽는 사람을 위한 것
  + 프로그램의 가독성을 높임
+ `#include <iostream>`은 전처리기 지시어
  + 전처리기(Preprocessor) : 본격적으로 컴파일 하기 전에 미리 어떤 처리를 하는 프로그램
  + 전처리기는 보통 컴파일러의 일부분으로 자동적으로 호출
  + 모든 전처리 지시어는 `#` 기호로 시작
  + `#include` : 특정한 파일을 소스 코드 안에 포함시킬 때 사용
  + `iostream` : 입출력에 필요한 클래스와 객체들이 정의되어 있음
+ `using namespace std;`
  + `using` : 이름 공간을 지정하는 지시어
  + 프로그램에서는 많은 이름(식별자)들이 사용되고 이 이름들은 효율성을 위하여 이름 공간(Name space)이라고 하는 몇 개의 영역으로 구성되어 있음
  + 이름 공간(Name space)은 동일한 이름을 여러 소프트웨어 개발자들이 사용할 수 있도록 함
  + 만약 `std`를 이름 공간으로 설정하지 않는다면 `std::cout << Hello, World!\n;`으로 사용
+ `main()` 함수의 정의
  + 함수(Function) : 입력이 주어지면 이것을 처리하여서 출력을 만들어내는 가상적인 상자, 특정한 작업을 수행하는 코드들을 모아놓은 상자
  + 함수 정의는 함수 헤더와 함수 몸체로 나눌 수 있음
    + `int main()` - 함수 헤더 : 함수의 입력과 출력을 나타내는 부분으로 함수와 외부를 연결시키는 역할
    + `{ ... }` - 함수 몸체 : 함수가 수행하는 작업을 기술하는 문장(Statement)들이 들어감(각각의 문장은 `;`으로 종료되어야 함)
+ 함수 헤더
  + 함수 헤더(Function header) : 외부와 함수 사이의 인터페이스 역할을 함
  + 함수는 외부의 함수로부터 호출될 수 있음
  + 함수는 호출 시 입력을 받을 수 있고 호출이 종료되면 자신을 호출한 함수에게 값을 반환할 수 있음
  + `main()` 앞의 `int`는 함수가 반환하는 값의 타입이 정수임을 표시
  + 함수 이름 뒤에 붙이는 괄호 안은 외부로부터 전달 받는 데이터를 나타냄
  + 빈 괄호만 있다는 것은 아무런 데이터도 받지 않음을 나타냄
  + 결론적으로 `main()` 함수는 자신을 호출한 함수로부터는 값을 ㅂ다지 않지만 정수값을 반환한다는 것을 의미
  + 모든 C++ 프로그램에서는 반드시 `main()` 함수가 하나 있어야 함
    + `main()` 함수는 프로그램에서 가장 먼저 실행되는 부분
    + 만약 프로그램에서 `main()` 함수가 정의되지 않으면 컴파일 단계에서 오류 발생